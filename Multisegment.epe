{
  "name": "Multisegment",
  "id": "FGhchHrXPz3TxYnJh",
  "sources": {
    "main": "/*\n Divide an LED strip into multiple segments or \"zones\", each\n with independent RGB settings and effects. Designed for easy JSON access\n to allow control from home automation hubs and the like.\n \n Version  Author        Date        Comment\n 1.0.0    JEM(ZRanger1) 07/20/2020 \n 1.0.1    JEM(ZRanger1) 07/22/2020  Add missing on/off switch to UI\n 1.0.2    JEM(ZRanger1) 10/27/2020  Add flag to enable/disable sliders\n*/\n\n// CONSTANTS \n// field indices for segment control array\nvar __state = 0;         // on/off state\nvar __hue = 1;           // hue (0-1 fixed point)\nvar __sat = 2;           // saturation (0-1 fixed point)\nvar __bri = 3;           // brightness (0-1 fixed point)\nvar __effect = 4;        // effect number\nvar __size = 5;          // number of pixels in segment\nvar __speed = 6;         // effect speed (for effects that support it)\n\n// dimensions of various data arrays\nexport var __n_segments = 4;    // number of segments\nvar __dataCols = 7;      // columns in segment control array\nvar __n_effects = 12;    // number of available effects\nvar __n_locals = 3;      // max number of per-segment local variables \n\n// GLOBAL VARIABLES \n// per-zone color/pattern control constants and data array declaration\nexport var activeSeg = 0;\n\n// vars for mild hack to isolate sliders from one another\nvar lastState = 0;\nvar lastColor = 0;\nvar lastEffect = 0;\nvar lastSpeed = 0;\nvar lastSize = 0;\n\n// Per segment data array.  There is no hardcoded limit to the \n// number of segments.  To add more, define z_<n> arrays for each\n// new segment, following the naming convention used below. Then\n// add your new arrays to segTable in the Initialize() function and\n// set the __n_segments variable to reflect the new number of zones. \n// That's it - everything else adapts automatically.\n//\n// The arrays are coded one per segment to reduce the amount of data that\n// an external program has to track per segment, as well as to\n// reduce the amount json needed to send a command to a single segment.\nexport var z_0 = array(__dataCols);\nexport var z_1 = array(__dataCols);\nexport var z_2 = array(__dataCols);\nexport var z_3 = array(__dataCols);\n\nvar segTable = array(__n_segments);\n\n// function tables for effects\n// two pointers per effect -- prerender and render\n// the last table entry is reserved for the \"off\" effect,\n// which cannot be selected by user input\nvar segPreRender = array(__n_effects)\nvar segRender = array(__n_effects);\n\n// current starting pixel index for each segment\nvar segStart = array (__n_segments + 1);\nsegStart[__n_segments] = 32765; // sentinel - do not change;\n\n// for fast checking during render -- is the segment\n// (1) turned on, (2) of non=zero size, and \n// (3) not pushed off the end by resizing.\nvar segEnabled = array(__n_segments);\n\n// per-segment scratch variable storage, used by effects\nvar localStore = array(__n_locals * __n_segments); \n\n// enable/disable the Pixelblaze Web UI sliders\n// If you're using multisegment with a home automation system,\n// they tend to interfere.  Consider using them for initial setup,\n// then disabling by setting this variable to 0 when you have everything\n// configured.\nvar useSliderUI = 1;\n\n// UI \nexport function sliderActiveSegment(v) {\n  if (!useSliderUI) return;\n  \n  lastSeg = activeSeg;\n  activeSeg = ceil(v * (__n_segments - 1));\n}\n\nexport function sliderState(v) {\n  if (!useSliderUI) return;  \n  \n  if (lastState != v) {\n    segTable[activeSeg][__state] = floor(v);\n  }\n  lastState = v;\n}\n\nexport function sliderEffect(v) {\n  if (!useSliderUI) return;  \n  \n  v = floor(v * (__n_effects - 1));\n  if (lastEffect != v){\n    segTable[activeSeg][__effect] = v;\n    lastEffect = v;\n  }\n}\n\nexport function sliderSpeed(v) {\n  if (!useSliderUI) return;  \n// set up so the default speed for a pattern falls in the \n// middle of the slider range, and moving right makes\n// things faster.\n  if (lastSpeed != v) {\n    segTable[activeSeg][__speed] = 2 * (1-v);\n    lastSpeed = v;\n  }  \n}\n\nexport function sliderSize(v) {\n  if (!useSliderUI) return;  \n  \n// can't directly change last segment from UI\n  if (activeSeg >= -1 + __n_segments) return;\n  \n  v = floor(v * (pixelCount - 1)); \n  if (lastSize != v){\n    segTable[activeSeg][__size] = v;\n    lastSize = v;\n  }\n}\n\nexport function hsvPickerColor(h, s, v) {\n  if (!useSliderUI) return;\n  \n  if (lastColor != (h+s+v)) {\n    segTable[activeSeg][__hue] = h;\n    segTable[activeSeg][__sat] = s;\n    segTable[activeSeg][__bri] = v;  \n    lastColor = h+s+v;;\n  }\n}\n\n// HELPER FUNCTIONS\nfunction SetRenderer(n,pre,rend) {\n  segPreRender[n] = pre;\n  segRender[n] = rend;\n} \n\nfunction GetVar(z,index) {\n  return localStore[(__n_locals * z)+index];\n}\n\nfunction SetVar(z,index,v) {\n  localStore[(__n_locals * z)+index] = v;\n}\n\n// Set size of zone, in pixels.  Zero is the minimum size,\n// pixelCount the maximum.  If you change the size of a zone,\n// the zones that follow it will have their sizes adjusted \n// as well. By definition, the first zone always starts at the\n// first pixel, and the last zone ends at the last pixel.\nfunction SetSegSize(z,nPixels) {\n  var usedPixels = 0;\n  \n  for (var i = 0; i < __n_segments; i++) {\n    var a = segTable[i];\n    if (i == z) { \n      a[__size] = nPixels;\n    }\n    else {\n      a[__size] = clamp(a[__size], 0, pixelCount - usedPixels);\n    }  \n    usedPixels += a[__size];\n  }\t  \n}\n\n// Set hsb color of the specified zone\nfunction SetSegHSB(z,h,s,b) {\n\tsegTable[z][__hue] = h;      // hue\n\tsegTable[z][__sat] = s;      // saturation\n\tsegTable[z][__bri] = b;      // brightness\n}\t\n\n// set on/off state of specified zone\nfunction SetSegState(z, state) {\n\tsegTable[z][__state] = state;\n}\n\n// set special effect for zone\nfunction SetSegEffect(z, effect) {\n\tsegTable[z][__effect] = effect;\n}\n\n// set effect speed for zone \nfunction SetSegSpeed(z,speed) {\n  segTable[z][__speed]=speed;\n}  \n\nfunction Initialize() {\t\n\n// initialize rendering function table  \n  SetRenderer(0,preDefault,renderDefault);\n  SetRenderer(1,preGlitter,renderGlitter);\n  SetRenderer(2,preRBounce,renderRBounce);\n  SetRenderer(3,preKITT,renderKITT);\n  SetRenderer(4,preBreathe,renderBreathe);\n  SetRenderer(5,preSlowColor,renderSlowColor);\n  SetRenderer(6,preSnow,renderSnow);\n  SetRenderer(7,preChaserUp,renderChaser);\n  SetRenderer(8,preChaserDn,renderChaser);  \n  SetRenderer(9,preStrobe,renderStrobe);\n  SetRenderer(10,preWipe,renderWipe);\n  SetRenderer(11,preSpringyTheater,renderSpringyTheater);\n\n// set up table of segment status arrays \n  segTable[0] = z_0;\n  segTable[1] = z_1;\n  segTable[2] = z_2;\n  segTable[3] = z_3;\t\n\n// start with all zones on, equal in size, and set to reasonable colors.\n//\n// IMPORTANT NOTE:\n// To customize your starting segment sizes and colors, you can \n// move the setup function calls (like SetSegSize and SetSegHSB)\n// from this loop and call them with the setup you want.\n   var i;\n   for (i = 0; i < __n_segments; i++) {\n      SetSegState(i,true);     \n\t    SetSegEffect(i,0)\n      SetSegHSB(i,i / __n_segments,1,0.60)\n      SetSegSpeed(i,1);\n      SetSegSize(i,floor(pixelCount / __n_segments));\n   }\n\n// TBD - add custom calls to zone setup functions here!\n\n} \n\n// EFFECTS FUNCTIONS\n// parameters for preXXX(z,a,delta) fns are:\n// z = seg index, a = ptr to segment data array, delta = ms since last frame\n// parameters for renderXXX(z,a,index) fns are:\n// z = seg index, a=ptr to segment data array, index=pixel index\n// Each effect can use up to 3 per segment local variables, accessed via\n// the GetVar/SetVar functions. \n\n// EFFECT: default -- all pixels set to current color\nfunction preDefault(z,a,delta) {\n}\n\nfunction renderDefault(z,a,index) {\n  hsv(a[__hue],a[__sat],a[__bri]);     \n}\n  \n// EFFECT - random pixel \"glitter\"\nfunction preGlitter(z,a,delta) {\n}\n\nfunction renderGlitter(z,a,index) {\n  if (random(1) < 0.02) {\n    hsv(a[__hue],a[__sat],a[__bri]);   \n  }\n  else {\n    hsv(0,0,0)\n  }\n}\n\n// EFFECT: rainbow bounce \nfunction preRBounce(z,a,delta) {\n  SetVar(z,0,wave(time(.03 * a[__speed])));\n}\n\nfunction renderRBounce(z,a,index) {\n  var h = GetVar(z,0) + ((index - segStart[z])/a[__size]);\n  hsv(h, 1, a[__bri]); \n}\n\n// EFFECT: minimalist KITT scanner\nfunction preKITT(z,a,delta) {\n  SetVar(z,0,max(3,a[__size] / 5)); \n  SetVar(z,1,triangle(time(.03 * a[__speed])) * a[__size]);\n}\n\nfunction renderKITT(z,a,index) {\n  var bri;\n  bri = 1 - clamp(abs((index - segStart[z]) - GetVar(z,1)) / GetVar(z,0), 0, 1);\n  bri = bri * bri  * a[__bri];\n  hsv(a[__hue],a[__sat],bri)\n}\n\n// EFFECT: pulse/flash\nfunction preBreathe(z,a,delta) {\n  SetVar(z,0,max(0.05,wave(time(.05 * a[__speed]))));\n}\n\nfunction renderBreathe(z,a,index) {\n  hsv(a[__hue],a[__sat],GetVar(z,0));\n}\n\n// EFFECT: slow color change\nfunction preSlowColor(z,a,delta) {\n  SetVar(z,0,time(.2 * a[__speed]));\n}\n\nfunction renderSlowColor(z,a,index) {\n  hsv(GetVar(z,0),a[__sat],a[__bri]);  \n}\n\n// EFFECT: light sparkling on snow!\nfunction preSnow(z,a,delta) {\n  var delay = delta + GetVar(z,0);\n\n  if (GetVar(z,1) < 0) {\n    if (delay > GetVar(z,2)) {\n       delay = 0;\n       SetVar(z,1,segStart[z] + floor(random(1) * a[__size])); \n       SetVar(z,2,random(750 * a[__speed])); \n    }\n  }\n  else if (delay > 80) {\n    SetVar(z,1,-1); \n    delay = 0;\n   }\n\n  SetVar(z,0,delay);\n}\n\nfunction renderSnow(z,a,index) {\n  if (index == GetVar(z,1)) { rgb(1,1,1); }\n  else { hsv(a[__hue],a[__sat],a[__bri]); }\n}\n\n// EFFECT: chaser up/down \nfunction preChaserUp(z,a,delta) {\n  SetVar(z,0,time(0.22 * a[__speed]));\n}\n\nfunction preChaserDn(z,a,delta) {\n  SetVar(z,0,1-time(0.22 * a[__speed]));\n}\n\nfunction renderChaser(z,a,index) {\n   var bri = sin(GetVar(z,0) * a[__size] + (index - segStart[z])); \n   hsv(a[__hue],a[__sat],bri); \n}\n\n// EFFECT: strobe\nfunction preStrobe(z,a,delta) {\n  SetVar(z,0,square(time(.003 * a[__speed]),0.75));  \n}\n\nfunction renderStrobe(z,a,index) {\n   hsv(a[__hue],a[__sat],a[__bri] * (1-GetVar(z,0)));   \n}\n\n// EFFECT: random color wipe\nfunction preWipe(z,a,delta) {\n  var index2 = floor(time(0.015 * a[__speed]) * a[__size]);\n\n  if (index2 < GetVar(z,0)) {\n    SetVar(z,1,GetVar(z,2));\n    SetVar(z,2,time(0.05));\n  }\n  SetVar(z,0,index2);\n}\n\nfunction renderWipe(z,a,index) {\n  var h = ((index - segStart[z]) <= GetVar(z,0)) ? GetVar(z,2) : GetVar(z,1);\n  hsv(h, 1, a[__bri]);\n}\n\nfunction preSpringyTheater(z,a,delta) {\n  SetVar(z,0,floor(time(0.3 * a[__speed]) * a[__size]));\n  SetVar(z,1,max(2,floor(triangle(time(0.1 * a[__speed])) * 10)));\n}\n\nfunction renderSpringyTheater(z,a,index) {\n  var v = ((GetVar(z,0) + (index-segStart[z])) % GetVar(z,1)) == 0;\n  hsv(a[__hue],a[__sat],v);\n}\n\n// PIXELBLAZE\n// evaluate current segment layout and call prerender\n// functions for active effects\n\nexport function beforeRender(delta) {\n\tvar start = 0;\t\n\n  for (var i = 0; i < __n_segments; i++) {\n    var a = segTable[i];   \n    \n      segStart[i] = start;\n      start += a[__size];   \n      segEnabled[i] = a[__state] && (segStart[i] < pixelCount) && (a[__size] > 0);\n\n    if (segEnabled[i]) segPreRender[a[__effect]](i,a,delta);\n  }\n  segNumber = 0;\n}\n\n// if segment is on, call rendering fn from table\n// if off, set pixel off.  Segments of zero length\n// are treated as \"off\".\nvar segNumber = 0;\nexport function render(index) {\n  if (index >= segStart[segNumber+1]) segNumber++;\n\n\t  if (segEnabled[segNumber]) {\n\t      segRender[segTable[segNumber][__effect]](segNumber,segTable[segNumber],index)\n  \t}\n  \telse {\n\t  \t  hsv(0,0,0);\n    }\n}\n\n// main entry point\nInitialize();\n\n\n\n\n"
  },
  "preview": "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"
}