{
  "name": "Multisegment for Automation",
  "id": "FGhchHrXPz3TxYnJh",
  "sources": {
    "main": "/*\n Multisegment Pattern for Home Automation Systems\n Divide an LED strip into multiple segments or \"zones\", each\n with independent RGB settings and effects. Designed for easy JSON access\n to allow control from home automation hubs.\n \n This version of the pattern is made to be controlled via websockets, so\n it does not support the Pixelblaze Web UI. \n \n Version  Author    Date        Comment\n 2.0.0    JEM       02/02/2021  v2 release\n 2.0.1    JEM       02/03/2021  fixed __state/__switch bug\n 2.0.2    \"         02/07/2021  fix unable to set color in glitter effect \n*/\n\n// CONSTANTS \n// field indices for segment control array\nvar __switch = 0;         // on/off state\nvar __hue = 1;           // hue (0-1 fixed point)\nvar __sat = 2;           // saturation (0-1 fixed point)\nvar __bri = 3;           // brightness (0-1 fixed point)\nvar __effect = 4;        // effect number\nvar __size = 5;          // number of pixels in segment\nvar __speed = 6;         // effect speed (for effects that support it)\n\n// dimensions of various data arrays\nvar __max_segments = 12;\nvar __dataCols = 7;        // columns in segment control array\nvar __n_effects = 19;      // number of available effects\nvar __n_locals = 3;        // max number of per-segment local variables\n\n// Variables visible to websockets\nexport var __ver = 2       // used to identify pattern version to automation driver\nexport var __n_segments = 4;  // number of segments (range 1-__max_segments)\nexport var __boot = 1;     // set to 0 by automation driver after setting segment data\nexport var __state = 0;    // currently running transition state. \n\n// GLOBAL VARIABLES \nvar fadeTime = 0         // accumulator for timing fade transitions\nvar fadeLength = 2000    // fade in/out time in milliseconds\nvar fadeLevel = 0        // transition brightness multiplier\nvar segBri = array(__max_segments)   // final segment brightness after all adjustments\n\n// beforeRender processing for fade in/fade out transitions\n// driver can invoke fades by setting the __state var w/websockets\nvar states = array(3)                 \nstates[0] = fadeIn;                  \nstates[1] = normalRun;\nstates[2] = fadeOut;\n\n/*\n Per segment data array. Twelve arrays are initially configured. The\n number of active segments is controlled by the variable __n_segments.\n\n If you need more than 12,define a new \"z_nn\" array for each new segment,\n add your new arrays to segTable in the Initialize() function and set the\n __max_segments and __n_segments variables to reflect the new number of \n segments you want. That's it - everything else adapts automatically.\n\n The arrays are coded one per segment to reduce the amount of data that\n an external program has to track per segment, as well as to\n reduce the amount json needed to send a command to a single segment.\n*/\nexport var z_0 = array(__dataCols);\nexport var z_1 = array(__dataCols);\nexport var z_2 = array(__dataCols);\nexport var z_3 = array(__dataCols);\nexport var z_4 = array(__dataCols);\nexport var z_5 = array(__dataCols);\nexport var z_6 = array(__dataCols);\nexport var z_7 = array(__dataCols);\nexport var z_8 = array(__dataCols);\nexport var z_9 = array(__dataCols);\nexport var z_10 = array(__dataCols);\nexport var z_11 = array(__dataCols);\n\nvar segTable = array(__max_segments);\n\n/*\n Function tables for effects\n Each effect requires two functions -- prerender and render\n the last table entry is reserved for the \"off\" effect,\n and cannot be selected by user input.\n*/\nvar segPreRender = array(__n_effects)\nvar segRender = array(__n_effects);\n\n// current starting pixel index for each segment\nvar segStart = array (__max_segments + 1);\nsegStart[__max_segments] = 32765; // end of list sentinel - do not change;\n\n// for fast checking during render -- is the segment\n// (1) turned on, (2) of non=zero size, and \n// (3) not pushed off the end by resizing.\nvar segEnabled = array(__max_segments);\n\n// per-segment local variable storage, used by effects\nvar localStore = array(__n_locals * __max_segments); \n\n// HELPER FUNCTIONS\nfunction SetRenderer(n,pre,rend) {\n  segPreRender[n] = pre;\n  segRender[n] = rend;\n} \n\nfunction GetVar(z,index) {\n  return localStore[(__n_locals * z)+index];\n}\n\nfunction SetVar(z,index,v) {\n  localStore[(__n_locals * z)+index] = v;\n}\n\n// Set size of zone, in pixels.  Zero is the minimum size,\n// pixelCount the maximum.  If you change the size of a zone,\n// the zones that follow it will have their sizes adjusted \n// as well. By definition, the first zone always starts at the\n// first pixel, and the last zone ends at the last pixel.\nfunction SetSegSize(z,nPixels) {\n  var usedPixels = 0;\n  \n  for (var i = 0; i < __n_segments; i++) {\n    var a = segTable[i];\n    if (i == z) { \n      a[__size] = nPixels;\n    }\n    else {\n      a[__size] = clamp(a[__size], 0, pixelCount - usedPixels);\n    }  \n    usedPixels += a[__size];\n  }\t  \n}\n\n// Set hsb color of the specified zone\nfunction SetSegHSB(z,h,s,b) {\n\tsegTable[z][__hue] = h;      // hue\n\tsegTable[z][__sat] = s;      // saturation\n\tsegTable[z][__bri] = b;      // brightness\n}\t\n\n// set on/off state of specified zone\nfunction SetSegState(z, state) {\n\tsegTable[z][__switch] = state;\n}\n\n// set special effect for zone\nfunction SetSegEffect(z, effect) {\n\tsegTable[z][__effect] = effect;\n}\n\n// set effect speed for zone \nfunction SetSegSpeed(z,speed) {\n  segTable[z][__speed]=speed;\n}  \n\nfunction Initialize() {\t\n\n// initialize rendering function table  \n  SetRenderer(0,preDefault,renderDefault);\n  SetRenderer(1,preGlitter,renderGlitter);\n  SetRenderer(2,preRBounce,renderRBounce);\n  SetRenderer(3,preKITT,renderKITT);\n  SetRenderer(4,preBreathe,renderBreathe);\n  SetRenderer(5,preSlowColor,renderSlowColor);\n  SetRenderer(6,preSnow,renderSnow);\n  SetRenderer(7,preChaserUp,renderChaser);\n  SetRenderer(8,preChaserDn,renderChaser);  \n  SetRenderer(9,preStrobe,renderStrobe);\n  SetRenderer(10,preWipeUp,renderWipe);\n  SetRenderer(11,preWipeDown,renderWipe)\n  SetRenderer(12,preSpringyTheater,renderSpringyTheater);\n  SetRenderer(13,preColorTwinkles,renderColorTwinkles);\n  SetRenderer(14,prePlasma,renderPlasma)\n  SetRenderer(15,preRipples,renderRipples)\n  SetRenderer(16,preSpinCycle,renderSpinCycle)\n  SetRenderer(17,preRainbowUp,renderRainbow)\n  SetRenderer(18,preRainbowDown,renderRainbow)\n\n// set up table of segment status arrays \n  segTable[0] = z_0;\n  segTable[1] = z_1;\n  segTable[2] = z_2;\n  segTable[3] = z_3;\t\n  segTable[4] = z_4;\n  segTable[5] = z_5;\n  segTable[6] = z_6;\n  segTable[7] = z_7;  \n  segTable[8] = z_8; \n  segTable[9] = z_9; \n  segTable[10] = z_10; \n  segTable[11] = z_11;   \n\n// For the Home Automation version of this pattern, we depend on the\n// automation controller to save and restore persistent segment data, so at initialization\n// time, all segments are simply set to equal length and a dimmed warm white.  \n  var def_segsize = floor(pixelCount/__max_segments);\n  for (var i = 0; i < __max_segments; i++) {\n    SetSegState(i,true);     \n    SetSegEffect(i,0);\n    SetSegHSB(i,0,1,0)\n    SetSegSpeed(i,1);\n    SetSegSize(i,def_segsize);      \n  }\n} \n\n// EFFECTS FUNCTIONS\n// parameters for preXXX(z,a,delta) fns are:\n// z = seg index, a = ptr to segment data array, delta = ms since last frame\n// parameters for renderXXX(z,a,index) fns are:\n// z = seg index, a=ptr to segment data array, index=pixel index\n// Each effect can use up to 3 per segment local variables, accessed via\n// the GetVar/SetVar functions. \n\n// EFFECT: default -- all pixels set to current color\nfunction preDefault(z,a,delta) {\n}\n\nfunction renderDefault(z,a,index) {\n  hsv(a[__hue],a[__sat],segBri[z]);     \n}\n  \n// EFFECT - random pixel \"glitter\"\n\n// xorshift* -- fast \"random enough\" PRNG \nvar rngState = random(32761)\nfunction xorShift() {\n  rngState ^= (rngState>>7);\n  rngState ^= (rngState<<9);\n  rngState ^= (rngState>>8)\n  return rngState;\n}\n\nfunction pRandom(seed) {\n  rngState = seed;\n  return xorShift() / 100 % 1\n}\n\nfunction preGlitter(z,a,delta) {\n  var delay = delta + GetVar(z,0);\n  \n  if (delay > (250 * a[__speed])) {\n    SetVar(z,1,random(32765));\n    delay = 0;\n  }\n  \n  SetVar(z,0,delay);  \n}\n\nfunction renderGlitter(z,a,index) {\n  b = pRandom(GetVar(z,1) * index) \n  hsv(a[__hue],1-(b*0.03),b*b*b);\n}\n\n// EFFECT: rainbow bounce \nfunction preRBounce(z,a,delta) {\n  SetVar(z,0,wave(time(0.2 * a[__speed])));\n}\n\nfunction renderRBounce(z,a,index) {\n  var h = GetVar(z,0) + ((index - segStart[z])/a[__size]);\n  hsv(h, 1, segBri[z]); \n}\n\n// EFFECT: minimalist KITT scanner\nfunction preKITT(z,a,delta) {\n  SetVar(z,0,max(3,a[__size] / 5)); \n  SetVar(z,1,triangle(time(0.2 * a[__speed])) * a[__size]);\n}\n\nfunction renderKITT(z,a,index) {\n  var bri;\n  bri = 1 - clamp(abs((index - segStart[z]) - GetVar(z,1)) / GetVar(z,0), 0, 1);\n  bri = bri * bri  * segBri[z];\n  hsv(a[__hue],a[__sat],bri)\n}\n\n// EFFECT: pulse/flash\nfunction preBreathe(z,a,delta) {\n  SetVar(z,0,max(0.05,wave(time(.15 * a[__speed]))));\n}\n\nfunction renderBreathe(z,a,index) {\n  hsv(a[__hue],a[__sat],GetVar(z,0) * segBri[z]);\n}\n\n// EFFECT: slow color change\nfunction preSlowColor(z,a,delta) {\n  SetVar(z,0,time(.2 * a[__speed]));\n}\n\nfunction renderSlowColor(z,a,index) {\n  hsv(GetVar(z,0),a[__sat],segBri[z]);  \n}\n\n// EFFECT: light sparkling on snow!\nfunction preSnow(z,a,delta) {\n  var delay = delta + GetVar(z,0);\n  \n  if (delay > (350 * a[__speed])) {\n    SetVar(z,1,random(32765));\n    delay = 0;\n  }\n  \n  SetVar(z,0,delay);  \n}\n\nfunction renderSnow(z,a,index) {\n  b = pRandom(GetVar(z,1) * index)\n  if (b > 0.94) { rgb(1,1,1); }\n  else { hsv(a[__hue],a[__sat],segBri[z]); }\n}\n\n// EFFECT: Chaser up/down \nfunction preChaserUp(z,a,delta) {\n  SetVar(z,0,time(0.44 * a[__speed]));\n}\n\nfunction preChaserDn(z,a,delta) {\n  SetVar(z,0,1-time(0.44 * a[__speed]));\n}\n\nfunction renderChaser(z,a,index) {\n   var bri = sin(GetVar(z,0) * a[__size] + (index - segStart[z])); \n   hsv(a[__hue],a[__sat],bri * segBri[z]); \n}\n\n// EFFECT: strobe\nfunction preStrobe(z,a,delta) {\n  SetVar(z,0,square(time(.01 * a[__speed]),0.25));  \n}\n\nfunction renderStrobe(z,a,index) {\n   hsv(a[__hue],a[__sat],segBri[z] * GetVar(z,0));   \n}\n\n// EFFECT: random color wipe Up/Down\nfunction preWipeDown(z,a,delta) {\n  var index2 = a[__size] - floor(time(0.035 * a[__speed]) * a[__size]);\n\n  if (index2 > GetVar(z,0)) {\n    SetVar(z,2,GetVar(z,1));\n    SetVar(z,1,time(0.05));\n  }\n  SetVar(z,0,index2);\n}\n\nfunction preWipeUp(z,a,delta) {\n  var index2 = floor(time(0.035 * a[__speed]) * a[__size]);\n\n  if (index2 < GetVar(z,0)) {\n    SetVar(z,1,GetVar(z,2));\n    SetVar(z,2,time(0.05));\n  }\n  SetVar(z,0,index2);\n}\n\nfunction renderWipe(z,a,index) {\n  var h = ((index - segStart[z]) <= GetVar(z,0)) ? GetVar(z,2) : GetVar(z,1);\n  hsv(h, 1, segBri[z]);\n}\n\nfunction preSpringyTheater(z,a,delta) {\n  SetVar(z,0,floor(time(0.4 * a[__speed]) * a[__size]));\n  SetVar(z,1,max(2,floor(triangle(time(0.1 * a[__speed])) * 10)));\n}\n\nfunction renderSpringyTheater(z,a,index) {\n  var v = ((GetVar(z,0) + (index-segStart[z])) % GetVar(z,1)) == 0;\n  hsv(a[__hue],a[__sat],v * segBri[z]);\n}\n\n// EFFECT: Port of color twinkles pattern\nfunction preColorTwinkles(z,a,delta) {\n  SetVar(z,0,time(0.8 * a[__speed]) * PI2);\n  SetVar(z,1,time(0.4 * a[__speed]) * PI2);\n}\n\nfunction renderColorTwinkles(z,a,index) {\n  var i = (index-segStart[z]);\n  var h = sin(i / 3 + PI2 *sin(i / 2 + GetVar(z,0)));\n  var v = wave( i / 3 / PI2 + sin(i / 2 + GetVar(z,1)));\n  v = v * v * v;\n  v =  (v > 0.1) ? v * segBri[z]: 0;\n  hsv(h,1,v);\n}\n\n// EFFECT: Port of Plasma pattern\nfunction prePlasma(z,a,delta) {\n  var t1 = time(0.2 * a[__speed]);\n  SetVar(z,0,t1);  \n  SetVar(z,1,2 * wave(t1));\n}\n\nfunction renderPlasma(z,a,index) {\n  var v = wave((GetVar(z,1) + (index-segStart[z])/a[__size]) % 1);\n  v = v * v * v;\n  hsv(GetVar(z,0),1.5-v,v * segBri[z])\n}\n\n// EFFECT: Ripples (kind of mini-oasis...)\nvar r1,r2,r3;\nfunction preRipples(z,a,delta) {\n  P10 = 10/a[__size];\n  P6 = 6/a[__size];\n  P3 = P6/2;\n  \n  r1 = time(0.24*a[__speed])\n  r2 = time(0.4*a[__speed])  \n  r3 = wave(time(.32*a[__speed]))\n}\n\nfunction renderRipples(z,a,index) {\n  index = index-segStart[z]\n  var w1 = 2*(wave(index*P10+ r1) - 0.5)\n  w1 = w1 * w1 \n  w2 = 2*(wave(index*P6 - r2) - 0.5)\n  w3 = 2*(wave(index*P3 + r3) - 0.5)\n  v = (w1+w2+w3)/3 ;\n  v = v * v * segBri[z];\n\n  hsv(a[__hue], a[__sat]-(v/2),v)\n}\n\n// EFFECT: Spin Cycle\nfunction preSpinCycle(z,a,delta) {\n  SetVar(z,0,time(0.5*a[__speed]))\n  SetVar(z,1,wave(time(0.25*a[__speed]))* 2)   \n}\n\nfunction renderSpinCycle(z,a,index) {\n  var i = index/pixelCount\n  var t1 = GetVar(z,0)\n  var h = i *(5+t1*5) + GetVar(z,1)\n  h = (h %.5) + t1\n  v = triangle(i*5 + t1*10)\n  v = v*v*v*segBri[z];\n  hsv(h,1,v)  \n}\n\n//EFFECT: Rainbow up/down\nfunction preRainbowUp(z,a,delta) {\n  SetVar(z,0,time(0.1*a[__speed]))\n}\n\nfunction preRainbowDown(z,a,delta) {\nSetVar(z,0,-time(0.1*a[__speed]))  \n}\n\nfunction renderRainbow(z,a,index) {\n  hsv(GetVar(z,0)+((index-segStart[z])/a[__size]),a[__sat],segBri[z])\n}\n\n// RENDER TIME FUNCTIONS\n\n// wait for the automation driver to initialize segment\n// data, then slowly fade in.\nfunction fadeIn(delta) {\n\tif (__boot) {\n\t  fadeLevel = 0;\n\t  fadeTime = 0;\n\t  return\n\t}\n\t\n\tfadeTime += delta;\n\tif (fadeLevel < 1) {\n\t  fadeLevel = min(1,fadeTime / fadeLength);\n\t  fadeLevel = fadeLevel * fadeLevel * fadeLevel;\n\t}  \n\telse {\n\t  state = 2;  // set to normal run state\n\t  fadeTime = 0;\n\t}\n}\n\nfunction fadeOut(delta) {\n\tfadeTime += delta;\n\tif (fadeLevel > 0) {\n\t  fadeLevel = max(0,1-(2 * fadeTime / fadeLength));\n\t  fadeLevel = fadeLevel * fadeLevel * fadeLevel;\n\t}  \n\telse {\n\t  state = 0;  // set to wait/fadeIn state\n\t  fadeTime = 0;\n\t}\n}\n\n// once the fade is complete, do nothing as\n// quickly as possible\nfunction normalRun(delta) { ; }\n\n// evaluate current segment layout and call prerender\n// functions for active effects\nexport function beforeRender(delta) {\n\tvar start = 0;\n\tvar i;\n\n\tstates[__state](delta);\n\t\n  for (i = 0; i < __n_segments; i++) {\n    var a = segTable[i];   \n    \n    segStart[i] = start;\n    start += a[__size];   \n    segEnabled[i] = a[__switch] && (segStart[i] < pixelCount) && (a[__size] > 0);\n    segBri[i] = a[__bri] * fadeLevel;\n\n    if (segEnabled[i]) segPreRender[a[__effect]](i,a,delta);\n  }\n  segStart[i] = 32765  // set sentinel value at end of list\n  segNumber = 0;\n}\n\n// if segment is on, call rendering fn from table\n// if off, set pixel off.  Segments of zero length\n// are treated as \"off\".\nvar segNumber = 0;\nexport function render(index) {\n  if (index >= segStart[segNumber+1]) segNumber++;\n\n\t  if (segEnabled[segNumber]) {\n\t      segRender[segTable[segNumber][__effect]](segNumber,segTable[segNumber],index)\n  \t}\n  \telse {\n\t  \t  hsv(0,0,0);\n    }\n}\n\n// main entry point\nInitialize();"
  },
  "preview": "/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAMCAgMCAgMDAwMEAwMEBQgFBQQEBQoHBwYIDAoMDAsKCwsNDhIQDQ4RDgsLEBYQERMUFRUVDA8XGBYUGBIUFRT/2wBDAQMEBAUEBQkFBQkUDQsNFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBT/wAARCACWAGQDAREAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD8qqACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKAP/Z"
}